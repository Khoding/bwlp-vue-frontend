# BW-Lehrpool, but VueJS

## The repos (quick links)

[New Repo (Khoding)](https://github.com/Khoding/bwlp-vue-frontend)

[Old Repo (Khoding, Archived) in case we need info](https://github.com/Khoding/bwlp-frontend)

## Info

This app uses [Vue.js](https://vuejs.org), [Vite](https://vite.dev) and [Beer CSS](https://www.beercss.com)

- Vue is Vue
- Vite is Vite
- and Beer CSS is a [Material UI](https://m3.material.io) CSS Library, it allows for quick Material designing, and it supports [Material You](https://m3.material.io/blog/announcing-material-you) customisation (theming color based off images and stuff like that, it's pointless, but cool for the user)
- The icons can be found at [Google Fonts](https://fonts.google.com/icons)

## Development rules (to keep the project clean)

I'm a code cleanliness you-know-what, so get ready.

### Vue SFCs (Single File Components), we love 'em

[SFC on vue.js documentation](https://vuejs.org/api/sfc-spec.html)

#### SFC parts order

Vue.js is inconsistent in their documentation and different websites and will sometimes use `script-template-style` order, however, it is recommended to use `template-script-style` order, so we do the following:

1. template `<template></template>`
2. (optional) script `<script setup></script>`

   - [Composition API](https://vuejs.org/api/composition-api-setup.html) The reason for the use of Composition API is that it's cleaner than the whole Options API's export default in terms of code, it's also the most modern of the two methods, and it's therefore more readable (yeah, they weren't gonna make the same mistake twice)

3. (optional) style `<style scoped></style>`

   [CSS Features in SFCs](https://vuejs.org/api/sfc-css-features.html)

   - style can just be last because it has the least impact on an SFC's readability
   - Use scoped styles in 99.9% of cases, if you need global CSS, put it in the main CSS file, if you have one of the specific cases where the CSS works weird within an SFC, use [`:global`](https://vuejs.org/api/sfc-css-features.html#global-selectors) on that specific rule, not on the entirety of the SFC's CSS, and give it a very specific class so it's not applied to divs project-wide or something
   - Try learning about [deep](https://vuejs.org/api/sfc-css-features.html#deep-selectors) and [slotted](https://vuejs.org/api/sfc-css-features.html#slotted-selectors) selectors
   - Note the following: [Scoped styles do not eliminate the need for classes](https://vuejs.org/api/sfc-css-features.html#scoped-style-tips) (giving classes to elements will make the code execute faster, among other advantages like readability)

The reasons this order works are as follows:

> Both orders work. Vue officially uses template-script-style in their documentation and examples. This order makes sense semantically since template defines the structure, script adds functionality, and style enhances appearance. But it's ultimately personal preference - pick one and stay consistent.
>
> - Generated by Claude AI, but check anywhere, it's basically the same reasons listed.

My (original developer of this particular web app, and following the "pick on and stay consistent" statement) reasons are the following:

> When you open an SFC Vue file, in most cases, you just need to read the template to know what's going on, you can guess the rest. If you can't, either your component is too complicated and could be broken down into smaller ones for readability, or it is warranted to be big, but you can easily find answers by scrolling down to the script.

> The script will sometimes be extremely long for a few lines of template, when you open it, you can't understand what will be displayed or how it will be displayed, so you have to scroll to find it, that's too much work in cases where you're just trying to debug and understand code.

### Templates

Nothing much to say, just when you're importing a component, use the relative `@` path, not relative `.` 'current location' path, it's longer, but that way, we know where the file is called from.

### JS

#### Extracting JS code

For the JS, if code gets too long in an SFC, it might be a good idea to extract it.

If the code is shared between many SFCs, try extracting it to a composable (for Vue-related code) or a utility (utils, for anything non Vue-related)

```js
// Examples of Vue and non-Vue-related codes, not in this project.
// formatDate.js, utility example
export function formatDate(date) {
  return new Date(date).toLocaleDateString();
}

// useCounter.js, composable example
import {ref} from 'vue';

export function useCounter() {
  const count = ref(0);

  function increment() {
    count.value++;
  }

  return {
    count,
    increment,
  };
}
```

#### NPM Packages

I know it's much easier to just install an NPM package for everything we need, but it creates weird dependencies that usually have no use and just make a mess in our package file, when something big is needed, go for it (site-wide stuff like i18n for example), but for small code, even if there is most likely a 10 LOC package that does it out there, try just making an 11 LOC file with basically the same logic (don't steal code though).

### CSS

### Selectors

Use classes for 99% of cases, never IDs (can cause many problems if we use ID in a potentially repeated component. Specific cases require ids (although not CSS), in those cases, just try making the id `name-of-component-${some-dynamic-value (not JS random, it'll fail at some point)}`), and very rarely just the tag (except html, body and main, those are fine, header and footer are often used at different places so not them, give 'em classes).

### !important

For the love of all things holy and Minecraft's Alex character (idek): Don't. Just don't. As Green Arrow would put it: "There is always another way."

#### CSS Reset and CSS Normalizer

Since we're using Beer CSS, this is handled by the package, the only reset introduced is the `border-box` rule because Beer only does it on `*`, not on `*::before` and `*::after` for some reason (not that I can see anyway), so just to be sure, I just added it again (also brings me peace knowing it's there, even if unfortunately repeated).

```css
*,
*::before,
*::after {
  box-sizing: border-box;
}
```

#### @import

Using CSS's `@import` in normal HTML CSS projects is often a bad idea, it introduces Sequential loading, blocks parallel downloads and adds HTTP requests. Vue, however, compiles CSS before serving it, so breaking down the files into smaller ones might be a good idea for long stuff that don't need to be in a single file (good example is the fonts declaration in this project, since it's long and, while somewhat overkill, still good practice (although we might want to introduce LightningCSS later to remove unecessary declarations)).

#### LTR and RTL

For CSS, always use logical properties (like `margin-inline-start` instead of `margin-left`), that way, if we ever want to support RTL languages, everything just "works" (on that end anyway, the rest is your problem).  
Beer CSS already does that for everything of the sort, so it's only in cases where you add some CSS.

#### Use of modern CSS

That's not a problem for me, although, I haven't used any feature that aren't supported on the latest versions of Evergreen Browsers (2022 and after (I cheated a little because who can not use `:has()` nowadays?)) (Google Chrome (and all Chromium, like Vivaldi (yaaa), Brave (why?), Opera GX (ew), Microsoft Edge (eh), etc.), Mozilla Firefox, Apple Safari. If it doesn't work on Internet Explorer, the old Edge or Opera (not GX), that's not our problem, anyway the chances of someone using them at the Uni are basically zero, and they probably have Chrome installed for the millions of websites not supporting their shitty choices in life).

##### Speaking of modern CSS, CSS Layers!

Okay, I know they are cool, and I planned on using them, but I don't want to force them on anyone, and since they can change the way Specificity works, I'd rather not confuse anyone with them.

## Recommended IDE Setup

[VSCode](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur).

### Snippets

For easier development, you can add these snippets to VS Code for the "Vue" language

```json
{
  "Vue Component": {
    "prefix": "vue-component",
    "body": [
      "<template>",
      "  $1",
      "</template>",
      "",
      "<script setup>",
      "  $2",
      "</script>",
      "",
      "<style scoped>",
      "  $3",
      "</style>"
    ],
    "description": "Create a Vue component"
  },
  "Vue Method": {
    "prefix": "vue-method",
    "body": ["${1:methodName}() {", "  ${2:// method body}", "}"],
    "description": "Create a Vue method"
  },
  "Vue Computed Property": {
    "prefix": "vue-computed",
    "body": [
      "computed: {",
      "  ${1:computedProperty}() {",
      "    return ${2:value};",
      "  }",
      "}"
    ],
    "description": "Create a Vue computed property"
  },
  "Vue Watcher": {
    "prefix": "vue-watch",
    "body": [
      "watch: {",
      "  ${1:propertyToWatch}(newValue, oldValue) {",
      "    ${2:// watcher body}",
      "  }",
      "}"
    ],
    "description": "Create a Vue watcher"
  },
  "Vue Script Setup": {
    "prefix": "setup",
    "body": ["<script setup>", "  $0", "</script>"],
    "description": "Create a vue script setup block"
  },
  "Vue Scoped": {
    "prefix": "scoped",
    "body": ["<style scoped>", "  $0", "</style>"],
    "description": "Create a scoped style block"
  }
}
```

## Customize configuration

See [Vite Configuration Reference](https://vite.dev/config/).

## Project Setup

```sh
npm install
```

### Compile and Hot-Reload for Development

```sh
npm run dev
```

### Compile and Minify for Production

```sh
npm run build
```
